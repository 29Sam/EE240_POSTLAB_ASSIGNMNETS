Q1) //Parameter given and calculated 
roll_no_last2 = 12;                         
Bs    = 0.95 + 0.01*roll_no_last2; 
alpha = 40;                                    
mu0   = 4*%pi*1e-7;                      
N     = 100;                                   
lc    = 0.1;                                     
Ac    = 30e-4;                              
f     = 50;                                   
w     = 2*%pi*f;
Vrms  = 80 + roll_no_last2;        
Vm    = sqrt(2)*Vrms;                  



//Look Up table 

H_step = 0.01;    //sampling- I am selecting  0.01 , not 0.001 it will be too large 
Hvec = -150:H_step:150;      // A/m (30001 points).   ((Startvalue:JUMP:STOPVALUE))
Bvec = Bs * tanh(Hvec ./ alpha) + mu0 .* Hvec;       



//Faraday’s Law 

num_cycles = 2;                     
points_per_cycle = 2000;     
t = linspace(0, num_cycles/f, num_cycles*points_per_cycle);  




 //This will generate num_cycle*points_per_cycle points in between 0 and num_cycles/f

Bt = ( -Vm / (N*Ac*w) ) .* cos(w .* t);      // I have derived this result in postal calculation sheet 




// Invert B(t) -> H(t) via interpolation of (Bvec,Hvec) 

//  Idea ::  Use linear interpolation. For Bt outside [min(Bvec),max(Bvec)]  we will not consider 
Bmin = Bvec(1);    // 1st element in Bvec 
Bmax = Bvec($);   //notation is used for last element 
H_t = zeros(1, length(t)); // preallocate.   [0 ,0 ,0…….0] array of size t is created 





// Now I will find those indices where Bt < Bmin or Bt > Bmax

low_idx  = find(Bt < Bmin);    
high_idx = find(Bt > Bmax);  
mid_idx  = find(Bt >= Bmin & Bt <= Bmax);   // this we can interpolate usingg our look up table 



// clamp extremes to nearest H

if ~isempty(low_idx) then.        //if there exists such low_index then assigning is done -low_index must be non empty
    H_t(low_idx) = Hvec(1);           //doing this to make use of the interpolation region only    
end
if ~isempty(high_idx) then
    H_t(high_idx) = Hvec($);
end



// interpolate the in-range points

if ~isempty(mid_idx) then
    H_t(mid_idx) = interp1(Bvec, Hvec, Bt(mid_idx), 'linear'); // returns H for each Bt
end

//interp1(x_known, y_known, x_query, 'method’).   -linearly interpolate 





// Compute current i(t)
i_t = (H_t .* lc) ./ N;        
// using the interpolated H of course and current In amperes 




//  5) Plots 
clf;
// Plot B-H lookup (for sanity)
subplot(3,1,1);
plot(Hvec, Bvec);
xlabel('H (A/m)');
ylabel('B (T)');
title('Precomputed B(H) Lookup');
xgrid();

// Plot B(t)
subplot(3,1,2);
plot(t, Bt);
xlabel('time (s)');
ylabel('B(t) (T)');
title('Flux density B(t) from applied voltage');
xgrid();

// Plot i(t)
subplot(3,1,3);
plot(t, i_t);
xlabel('time (s)');
ylabel('i(t) (A)');
title('Current waveform i(t) through nonlinear inductor');
a = gca();
a.data_bounds = [t(1), -5; t($), 5];
xgrid();

Q2)clc;
clear;
close;


// Parameters and also some basic calcs 

N = 100;              
A = 60e-4;             
lc = 0.10;             
Bsat = 1.2;          
Hc = 20;                
x1 = 150;             
zeta = 40;             
mu0 = 4 * %pi * 1e-7;  

Vm = 220;           
f = 50;                 
w = 2 * %pi * f;       

//graphical settings just like the previous Q1 given in postab 
cycles = 2;
points_per_cycle = 2000;
t = linspace(0, cycles/f, cycles * points_per_cycle);




// B computation in both branches 

H_up = -150:0.5:150;    // Ascending branch range
H_down = 150:-0.5:-150; // Descending branch range


// Compute Ascending branch B_up
B_up = Bsat * (tanh((H_up - Hc)/zeta) + ...
       (tanh(x1 + Hc) - tanh(x1 - Hc))/2) + mu0 * H_up;

// Compute Descending branch B_down
B_down = Bsat * (tanh((H_down + Hc)/zeta) - ...
        (tanh(x1 + Hc) - tanh(x1 - Hc))/2) + mu0 * H_down;




// STEP 2: Plot B-H Curve
scf(1);
plot(H_up, B_up, 'r', H_down, B_down, 'b');
xlabel('H (A/m)');
ylabel('B (T)');
title('B-H Hysteresis Loop');
legend(['Ascending'; 'Descending'], 2);
xgrid();


//  Compute B(t) from Voltage

B_t = -(Vm/(N*A*w)) * cos(w*t);



// STEP 4: Compute H(t) by interpolation

H_t = zeros(1, length(B_t));
prev_branch = 1; // Start with ascending branch

for k = 2:length(t)
    dB = B_t(k) - B_t(k-1);
    
    if dB > 0 then
        // Ascending
        H_t(k) = interp1(B_up, H_up, B_t(k), "linear", "extrap");
        prev_branch = 1;
    elseif dB < 0 then
        // Descending
        H_t(k) = interp1(B_down, H_down, B_t(k), "linear", "extrap");
        prev_branch = 2;
    else
        // If B is constant, use previous branch
        if prev_branch == 1 then
            H_t(k) = interp1(B_up, H_up, B_t(k), "linear", "extrap");
        else
            H_t(k) = interp1(B_down, H_down, B_t(k), "linear", "extrap");
        end
    end
end


//  Compute current i(t)

i_t = (H_t * lc) / N;



//  Plot current 

scf(2);
plot(t, i_t);
xlabel('Time (s)');
ylabel('Current (A)');
title('Current drawn by the inductor');
a = gca();
a.data_bounds = [0, -0.02; 0.04, 0.16]; // Zoom in like reference plot
xgrid();
